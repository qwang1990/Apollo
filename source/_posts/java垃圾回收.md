---
title: java垃圾回收
date: 2018-03-25 21:18:57
categories: 
- 后端 
tags: 
- java 
---

# java 垃圾回收
其实很多书都很系统的讲过垃圾回收，我只是把知识点串一下。

## 几个小问题

- 第一个问题，垃圾回收是基于什么的？
> 基于GC Root枚举(这个比较基础，就不多说了。)

- 第二个问题，如何高效的GC Root枚举？
> 这时就需要一个地方来记录对象引用，Oop来记录哪些地方存着对象引用。

- 第三个问题，虽然Oop记录了这些信息，但是不能每条指令都生成Oop，这样效率太低了，那应该怎么办呢？

> 这时就引入了安全点(safepoint)这个概念，程序不是任何时间都能停下来GC的，只有到安全点的时候才能暂停。所以只要在安全点时记录Oop信息就行了。

- 第四个问题，安全点怎么选？
> 原则:是否有让程序长时间执行的特征。例如:方法调用，循环跳转，异常跳转等。

- 第五个问题，怎么让程序到安全点后都停下来？
> 理论上两种方式，抢先式中断&主动式中断，抢先式不用代码配合，在GC发生的时候，先把全部线程中断，然后不再安全点的就恢复它，然后让它跑到安全点，这个基本没人这么做。而主动式是需要中断的时候不用对线程操作，只是设个标识，然后线程主动轮询这个标识。轮询标识的地方其实就是安全点。

- 第六个问题，在程序“不执行”的时候，例如sleep或block住了，如果走到安全点？
> 首先这个时候线程无法响应JVM的中断请求，走到安全点，JVM也不可能等到线程获得CPU时间。这时就引入安全区域。

- 最后一个问题，安全区域是什么？
> 安全区域就是指一段代码片段中引用关系不会变化。在该区域内任何地方GC都是安全的。可以把它看成扩展后的安全点。所以当线程执行到安全区域里的代码时，首先它自己要意识到自己已经在其中了，这段时间内GC就不要管它了，在离开安全区域时，它要检查根枚举完成了没，如果没完成他要等到完才能离开安全区域。

这几个问题能帮助大家理解垃圾回收中的一些词的概念。

## 主要垃圾回收器的简介

先上图
![image](https://user-images.githubusercontent.com/13915081/37282784-a98bfd5a-2630-11e8-932f-be3d7900120b.png)

### Serial new
早期(JDK1.3.1之前)的新生代收集的唯一选择，单线程，它收集的时候要停止所有用户线程。Stop The World!
![image](https://user-images.githubusercontent.com/13915081/37283034-7e59b770-2631-11e8-8aee-e96f3019ad18.png)

- 缺点: 这个很明显就不说了。
- 优点: 简单高效，特别对单CPU来说。所以在client模式下是一个很好的选择

### ParNew 
就是Serial收集器的多线程版本。
![image](https://user-images.githubusercontent.com/13915081/37283228-2d5da2ea-2632-11e8-9075-6f4608756cc1.png)
其实没太多创新，但是确实Server模式下新生代收集的首选，因为它是出Serial外，目前唯一能和CMS收集器配合工作的。

ParNew在单CPU下绝对不会比Serial号。但是随着CPU数量的增加，它还是会更充分的利用系统的资源的。

### Parallel Scavenge
新生代收集器，也是复制算法收集，但是它的关注点是吞吐量。吞吐量就是CPU用于运行用户代码的时间和CPU总消耗时间的比。

所以停顿时间越短就越适合于用户交互，良好的响应速度能提升用户体验，而搞吞吐量能高效的利用CPU时间。

Parallel提供了配置最大停顿时间和吞吐量大小的参数。

### Serial Old
就是Serial的老年版收集器，用标记-整理算法，单线程。
两个主要用途: 
- 与Parallel Scavenge收集器搭配使用
- 座位CMS的后备方案，当其发生Concurrent Mode Failure时(这个后面会讲。)


## Parallel Old
是Parallel Scavenge的老年代版本，多线程&标记-整理。
主要用于和Parallel Scavenge在CPU资源敏感的场合使用。

### CMS
CMS是以获得最短停顿时间为目标的收集器。标记-清除算法。它有如下4个步骤

- 初始标记(只标记GC Roots能直接关联的对象，所以很快!)
- 并发标记(和用户线程并行)
- 重新标记(修正了并发标记期间因为用户程序导致变化的记录,它的停顿时间比初始标识长，但远小于并发标记)
- 并发清除(与用户线程并行)

![image](https://user-images.githubusercontent.com/13915081/37283757-13e846f6-2634-11e8-907b-04cac4c61e5a.png)

其中初始标记和重新标记还是要stop the world的。

缺点：

- 对CPU资源敏感。因为并发标记，并发清除不会导致程序停，但是会占用CPU。
- 无法处理浮动垃圾，可能会Concurrent Mode Failure，导致另外一次Full GC。因为CMS并发清除的时候用户线程可能还会产生垃圾，而这部分垃圾在标记之后，所以只能等到下次。因为垃圾回收阶段程序还在跑，所以还要预留空间。默认老年代使用68%后激活，当然你也可以设高点，不过CMS运行期间如果预留内存无法满足程序需要，就要Serial Old了，这个比较慢。
- 最后一个缺点，标记-清除有碎片，当碎片过多无法分配大对象的时候就要提前触发一次full GC。所以CMS有一个参数(自己查),用于在CMS顶不住要FullGC的时候开始内存合并整理。它还有个参数用于设置执行多少次不压缩的FullGC后来一个压缩的。

### G1
现在已经成熟，最新的信息我后面查一下补充，现在只说一下它的设计思路。
![image](https://user-images.githubusercontent.com/13915081/37284663-6a3d148e-2637-11e8-881e-64a74ddf1b58.png)

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始看起来这个和CMS差不多，连步骤和并发的点都差不多，其实大大的不同。
首先说一下它的优点：

- 并发&并行: 这点和CMS差不多，就是最大限度的并发。
- 分代收集: G1中也采用不同的方式去处理新对象和老对象，但是它不用其他回收期配合
- 空间整合: 它整体看起来是标记-整理，从局部(两个Region之间)上看起来是复制算法。不过无论哪种都不会有碎片。关于region，后面再说。
- 可预测的停顿: 这个也是G1的一大优势，G1能建立可预测的停顿时间模型，能让使用者明确在一个长度为M毫秒的时间片内，消费在垃圾收集上的时间不超过N毫秒。

在G1之前，别的收集器都是老年代和新生代，但是G1不是这样了，G1把JAVA堆分成了很多大小相等的独立的区域(Region)，虽然还是有新生代和来年代的概念，但是他们不再是物理隔离了，他们都是一部分region(不需要连续)的集合。

G1通过跟踪各个region里垃圾堆积的价值大小(回收获得的空间大小以及回收时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。

其实这里就引入一个问题，region不是独立的，那么一个region中的对象可能会引用其他region的对象。这样的话不就要扫描全部的堆对象了么？
其实不仅仅是G1，在原来的垃圾回收器中也有类似的问题，所以在G1中region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机是使用Remebered set来记录的。

G1的每个Region都有一个和它对应的Remebered set，虚拟机发现程序对reference类型进行写操作时就会产生一个write barrier的写中断，检查该引用是否引用了其他region的对象(在分代收集的时候就会坚持老年代是否应用了新生代的对象)，如果是，就通过CardTable吧相关应用对象所属的region记录在Remebered set中。









